<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ephz3nt</title><link>https://painso.com/</link><description>Recent content on ephz3nt</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 09 Sep 2020 21:55:43 +0800</lastBuildDate><atom:link href="https://painso.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Google SRE 生存指南笔记</title><link>https://painso.com/posts/tech/2020/real-world-sre-notes/</link><pubDate>Wed, 09 Sep 2020 21:55:43 +0800</pubDate><guid>https://painso.com/posts/tech/2020/real-world-sre-notes/</guid><description>SRE简介 SRE是指Site Reliability Engineer (网站可靠性工程师)。他是软件工程师和系统管理员的结合，一个SRE工程师基本上需要掌握很多知识：算法，数据结构，编程能力，网络编程，分布式系统，可扩展架构，故障排除。 - 百度百科
Site： 一个网站 Reliability： 被定义为&amp;quot;值得信赖的质量或一贯可靠的质量&amp;rdquo; Engineering： 被定义为&amp;quot;熟练地运用技巧以达到某种目的的行动&amp;rdquo; 《SRE 生存指南》- Nat Welch 系统中断响应与正常运行时间最大化
语录 故障是常态，正常才是异常 个人不应该害怕事故，而是要确信如果事故发生，团队将会响应和改进系统，而不是关注发生事故带来的耻辱和愤怒。事故是我们可以从中学习的东西，而不是让人害怕和羞耻的事情！ 1. 简介 SRE的目标是提高服务可靠性，帮助业务实现并改善用户的服务体验 SRE定义： 一个专注于熟练地维护一个网站以使其持续可靠的领域 互联网上的软件永远做不到完全可靠，这里有两个原因
互联网是一个分布式系统，各部分经常出现故障，这会影响服务可用性。 软件是人编写的，所以Bug不可避免，而Bug会导致系统宕机。 可靠性层次结构 Mikey Pyramid
用户体验 开发 容量规划 测试与发布 事后回顾 事故响应 监控 以上七点都被沟通所包围，因为每一层都需要沟通才能成功。
在加入或新项目评估新服务时，请遵循下面的一系列步骤
弄清楚团队结构。团队里谁负责什么？谁说了算？ 查找团队为其服务或项目编写的任何文档。 让某人绘制出系统架构图。让他们向你展示什么连接到哪个服务、什么依赖于这个项目、数据如何流经服务，以及项目如何部署。 进行每个环节时提出以下问题</description></item><item><title>Java 线程</title><link>https://painso.com/posts/tech/2020/java-thread/</link><pubDate>Mon, 07 Sep 2020 21:06:51 +0800</pubDate><guid>https://painso.com/posts/tech/2020/java-thread/</guid><description>观看至： https://www.bilibili.com/video/BV1V4411p7EF?p=23
什么是任务、进程、线程 多任务表示一个人边吃饭边玩手机，看上去是同时进行，实际上这一秒在吃饭下一秒在玩手机，只是切换时间很短感觉不出来 说道进程就得提程序，程序运行会创建一个进程，里面包含一个主线程如main函数，还有其他语言自带的守护线程如Java的GC 线程不一定立即执行，它是由CPU调度的 线程的三种创建方式 Thread class 继承Thread类
不建议使用： 避免OOP单继承局限性 创建一个Class继承Thread class并重写run()方法，启动线程使用.start() package com.painso.study.thread.demo01; // create thread way 1: extend Thread class, override run() method, call start enable thread public class D1 extends Thread{ @Override public void run(){ // run() body for (int i = 0; i&amp;lt;20;i++){ System.out.println(&amp;#34;i&amp;#39;m run() body &amp;#34;+i); } } public static void main(String[] args) { // main() body D1 d1 = new D1(); d1.</description></item><item><title>微星B460主板安装Linux问题</title><link>https://painso.com/posts/tech/2020/msi-b460-motherboard-linux-issue/</link><pubDate>Wed, 02 Sep 2020 20:14:05 +0800</pubDate><guid>https://painso.com/posts/tech/2020/msi-b460-motherboard-linux-issue/</guid><description>今天公司到了一台内网测试用服务器，想着直接装好Ubuntu 16.04配置好网络直接扔杂物间(没有机房，只能放那边挨着交换机)
没想到我的U盘直接认不到了，我是用YUMI把好几个系统装到U盘里的，我自己用的办公电脑是ok的，后面网上查了下说要吧BIOS里面的UEFI改成CMS 兼容模式，结果直接点不亮了。
没办法，拆开机箱取主板电池下来放电重新来
重新用YUMI把ISO刻到U盘后发现竟然神奇的可以了，兴奋的等待安装完毕后蛋疼的事情又来了。
装完后启动黑屏，我折腾了好一会才发现是进入系统黑屏，不是系统没装好。
之前我自己的办公电脑装也是这个样子，我尝试开机后按上下键在Ubuntu启动界面编辑启动项在后面加上nomodeset，貌似和显卡有关系。结果能看到启动的界面了，但是卡在磁盘扫描那边。
想着之前自己的办公电脑也差不多是这样，Manjaro、Archlinux 都不行，后面换Linux Mint完美运行。接着自己吧它也刻进去，进入到LiveCD桌面，点安装然后下一步下一步。。。到在线更新包的时候提示网络问题，ifconfig看了下就一块lo网卡，应该是找不到网卡驱动了，lspci看了下ethernet信息，网卡型号是RTL8125 Realtek PCIe FE / GBE / 2.5G ，我先跳过在线更新直接把系统先装了再说。
完事后在自己办公电脑从官网下载驱动 https://www.realtek.com/en/component/zoo/category/network-interface-controllers-10-100-1000m-gigabit-ethernet-pci-express-software
选择Unix (Linux)下的2.5G Ethernet LINUX driver r8125 for kernel up to 5.6 下载后拷贝到U盘，然后插上服务器挂载，解压运行./autorun.sh正常执行完后运行lsmod | grep 8125应该就可以看到显示了。ifconfig -a 也能看到网卡信息。
安装驱动需要 gcc kernel-dev等包，如果没有的话需要先安装，我是正好有一个USB装RJ45的线。
接着配置好静态IP明天再部署环境。
最后再吹一波 Linux Mint的兼容性！
后记 弄好之后用kubeadm部署了个单机版kubernetes，用第二块nvmeSSD去做k8s的sc
用glusterfs+heketi实现，heketi-cli topology load --json cluster.json的时候提示
Adding device /dev/nvm0n1 ... Unable to add device: Setup of device /dev/vdb failed (already initialized or contains data?</description></item><item><title>Java 基础</title><link>https://painso.com/posts/tech/2020/java-basic/</link><pubDate>Sun, 23 Aug 2020 17:25:46 +0800</pubDate><guid>https://painso.com/posts/tech/2020/java-basic/</guid><description>狂神说JAVA学习笔记 - JavaSE基础部分 Bilibili: https://www.bilibili.com/video/av68373450
当前观看至: https://www.bilibili.com/video/av68373450?p=77
运算符 不同类型运算返回值
double a = 55; float b = 10F; long c = 10; int d = 20; short e = 25; byte f = 25; 如果变量a+b+c+d相加，返回值类型为double 如果变量b+c+d+e相加，返回值类型为float
如果d+e相加，返回值为int 如果e+f相加，返回值为int 。。。 结论
如果一组不同类型的变量进行运算，返回值取类型最大数据类型 如果其中最大的数据类型为int，返回值为int
如果小于int的类型，返回int 自增、自减 ++ --
package operator; public class Demo01 { public static void main(String[] args) { int a = 1; int b = a++; int c = ++a; System.</description></item><item><title>Java 变量作用域</title><link>https://painso.com/posts/tech/2020/java-variable-scope/</link><pubDate>Sun, 23 Aug 2020 16:50:36 +0800</pubDate><guid>https://painso.com/posts/tech/2020/java-variable-scope/</guid><description>Java 变量分为: 类变量 实例变量 局部变量 类变量 需要在变量前添加修饰符static，可以在方法中直接调用
public class Hello { static int number = 10; // 定义类变量 public static void main(String[] args) { System.out.println(number); // 直接调用 } } 实例变量 定义格式为String &amp;lt;type&amp;gt; &amp;lt;name&amp;gt; = &amp;lt;value&amp;gt;;
实例变量从属于对象，使用时需要进行初始化
public class Hello { // 定义实例变量 String name = &amp;#34;Benjamin&amp;#34;; int age = 18; public static void main(String[] args) { Hello instance = new Hello() ; // new 一个当前的Hello对象 System.</description></item><item><title>Manjaro 添加自定义快捷方式</title><link>https://painso.com/posts/tech/2020/manjaro-custom-shortcut/</link><pubDate>Sat, 22 Aug 2020 21:19:42 +0800</pubDate><guid>https://painso.com/posts/tech/2020/manjaro-custom-shortcut/</guid><description>今天装了个Goland, 由于没有像Ubuntu那样的deb包导致每次启动都需shell进相应目录执行
./goland.sh 非常麻烦
稍微找了下资料
首先进入 &amp;ldquo;/usr/share/applications&amp;rdquo; 目录, 可以看到里面有很多的 .desktop 文件, 这就是快捷方式文件了
可以随便找一个复制出来, 如:
sudo cp idea.desktop goland.desktop 文件大概长这样, 怎么改一目了然了 路径按照自己实际目录修改就行.
goland.desktop
[Desktop Entry] Version=1.0 Type=Application Name=Goland Comment=Develop with pleasure! Exec=/home/ephz3nt/Downloads/GoLand-2020.2.2/bin/goland.sh %f Icon=/home/ephz3nt/Downloads/GoLand-2020.2.2/bin/goland.png Terminal=false StartupNotify=true StartupWMClass=jetbrains-goland Categories=Development;IDE;Go; 顺便贴一下Typora的配置吧, 正好今天在用
[Desktop Entry] Version=1.0 Type=Application Name=Typora Comment=Typora Markdown Editor Exec=/home/ephz3nt/Downloads/Typora-linux-x64/Typora %f Icon=/home/ephz3nt/Downloads/Typora-linux-x64/resources/app/asserts/icon/icon_128x128.png Terminal=false StartupNotify=true #StartupWMClass=jetbrains-goland Categories=Development;Markdown;Typora;</description></item><item><title>snap 设置HTTP代理</title><link>https://painso.com/posts/tech/2020/snap-set-proxy/</link><pubDate>Sat, 22 Aug 2020 20:58:13 +0800</pubDate><guid>https://painso.com/posts/tech/2020/snap-set-proxy/</guid><description>这里由于我用的是V2RAY, 代理端口 &amp;ldquo;12333&amp;rdquo;
sudo snap set system proxy.http=&amp;#34;http://127.0.0.1:12333&amp;#34; sudo snap set system proxy.https=&amp;#34;http://127.0.0.1:12333&amp;#34; 酸爽！</description></item><item><title>博客迁移至github &amp; hugo。</title><link>https://painso.com/posts/thinking/2020/migrated-to-hugo/</link><pubDate>Tue, 03 Mar 2020 18:32:00 +0000</pubDate><guid>https://painso.com/posts/thinking/2020/migrated-to-hugo/</guid><description>从wordpress到hexo，从hexo到hugo 搭配git-pages 实现白嫖 准备重拾博客</description></item><item><title>使用acme签发&amp;续期 Let's Encrypt 证书。</title><link>https://painso.com/posts/tech/2017/acme-lets-encrypt-issue/</link><pubDate>Tue, 28 Feb 2017 14:57:48 +0000</pubDate><guid>https://painso.com/posts/tech/2017/acme-lets-encrypt-issue/</guid><description>acme.sh 实现了 acme 协议, 可以从 letsencrypt 生成免费的证书.
使用它的原因是 acme.sh 支持DNS API方式签发证书,这可方便太多了
支持的DNS服务商有: cloudflare, dnspod, cloudxns, godaddy 以及 ovh 等数十种解析商的自动集成.
[root@ROOT ~]# ls .acme.sh/dnsapi/ dns_ad.sh dns_cf.sh dns_do.sh dns_gd.sh dns_linode.sh dns_myapi.sh dns_pdns.sh dns_ali.sh dns_cx.sh dns_dp.sh dns_ispconfig.sh dns_lua.sh dns_nsupdate.sh README.md dns_aws.sh dns_cyon.sh dns_freedns.sh dns_lexicon.sh dns_me.sh dns_ovh.sh 获取acme.sh
curl https://get.acme.sh | sh 将安装acme.sh至你当前账户根目录下的 .acme.sh下
创建一个bash的alias, 方便直接使用acme.sh
vim ~/.bashrc 增加一行 alias acme.sh=~/.acme.sh/acme.sh
# .bashrc # User specific aliases and functions alias acme.sh=~/.acme.sh/acme.sh alias rm=&amp;#39;rm -i&amp;#39; alias cp=&amp;#39;cp -i&amp;#39; alias mv=&amp;#39;mv -i&amp;#39; 执行 source .</description></item><item><title>陈佩斯&amp;朱时茂 主角与配角</title><link>https://painso.com/posts/share/2017/chenpeisi-zhushimao-zhujueyupeijue/</link><pubDate>Fri, 13 Jan 2017 20:26:48 +0000</pubDate><guid>https://painso.com/posts/share/2017/chenpeisi-zhushimao-zhujueyupeijue/</guid><description/></item></channel></rss>